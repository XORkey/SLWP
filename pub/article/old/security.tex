% $Header: /usr/local/src/slwp/article/security.tex,v 1.1 2013/03/09 15:28:32 timo Exp $
\section{Security proof}
All exchange of data between user and webserver should be transported over a secure channel.
Not that the login sequence would be directly vulnerable,
but for the other data that is transported.
Requiring a login implies the subsequent exchange of private, valuable, or secret data in almost all cases.
\subsection{On random numbers}
The login sequence is an exchange of random data.
The random numbers used in this exchange are generated by two sources:
the pseudo-random generator of the system running the webbrowser and that of the login server.
\par
When encrypting valuable data,
using pseudo-random numbers that are generated with weak algorithms,
or are weak themselves,
eases decryption.
In this case,
however,
there is nothing valuable to encrypt;
only random bits.
Cryptanalysis of random data is very hard.
\par
Having a poor pseudo-random generator on the system running the webbrowser,
as is typically the case for home-use equipment like PCs,
tablets,
or smartphones,
does not really hurt,
because this is the ``valuable data'' that is encrypted.
It does not really matter which value is used for this,
in this login scheme
(but see section~\ref{sec:manipulating_values}).
\par
The random numbers generated by the login server are of good quality,
for they are created by the pseudo-random generator of the HSM.
These random numbers are used for site keys and can be considered strong.
User keys are directly dependent of these keys,
so they can be considered strong as well.
\subsection{Eavesdropping the connections}
Somebody able to eavesdrop on the exchange of values between the user
and the webserver will see several values being transmitted.
An attempt is made to prove that these values are of little use to a hacker.
%%%%%%%%%%%%%%%
\subsubsection{Applying for an account}
To prevent having sets of keys in plain-text in one location,
there is a pre-shared key,
which is shared between the accounts server in the back-office and the login server somewhere on the Internet.
The encrypted values pass the webserver,
but the webserver has no copy of this key.
\par
The webserver receives a dummy key of the user,
which should not be sent to the accounts server.
This way,
no set of site key and user key will arrive at the accounts server.
%^^^^^^^^
\paragraph{Values passing the webserver}
A user fills in a form on a webpage to supply enough information for the creation of a new account.
It also must send a dummy key and a hash.
The webserver sends values to the login server and relays the results to the accounts server.
\begin{description}
\item[$K_d$]	A dummy key from the keyring.
	This dummy key has no information and cannot be used to decrypt anything at the webserver.
\item[$U_h$]	A special \SHA\ hash (see section \ref{sec:user_ids}) dependent of the userid.
	Relayed as-is to the accounts server.
\item[Email address]	To which the new key will be sent.
	Relayed as-is to the accounts server.
	Although this data has privacy aspects they are considered of no value in this context.
\item[User details]	To fill the accounts database with.
	Relayed as-is to the accounts server.
	Although this data has privacy aspects they are considered of no value in this context.
\item[$E_s$]	New site key (encrypted with pre-shared key) returned by the login server.
	The webserver has no knowledge of the pre-shared key,
	so $K_s$ cannot be decrypted without obtaining this from the login server or the acccounts server.
\item[$E_x$]	Encrypted key (encrypted with pre-shared key) returned by the login server.
	The webserver has the user dummy key,
	but with that key only the value $\XOR{K_u}{K_w}$ can be obtained.
\end{description}
%^^^^^^^^
\paragraph{Values passing the login server}
\begin{description}
\item[$K_d$]	The dummy key the user will replace with the new key later on.
\item[$W$]	An indication to which website the request pertains.
	Used to select the right pre-shared key for the exchange of values with the accounts server.
\item[$E_s$]	New site key (encrypted with pre-shared key) returned to the webserver.
\item[$E_x$]	Encrypted key (encrypted with pre-shared key) returned to the webserver.
\end{description}
%^^^^^^^^
\paragraph{Values passing the accounts server}
\begin{description}
\item[$U_h$]	The \SHA\ hash value from the user.
\item[$E_s$]	New site key (encrypted with pre-shared key) as obtained from the login server.
\item[$E_x$]	Encrypted user key (encrypted with pre-shared key) as obtained from the login server.
\item[$K_x$]	Encrypted user key is sent out over a separate channel.
\item[Email address]	To which the new key will be sent.
\item[User details]	To fill the accounts database with.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Logging in}
%^^^^^^^^
\paragraph{Values passing the webserver}
\begin{description}
\item[$U_h$]	A special \SHA\ hash dependent of $Z[0]$ and the userid is sent to the webserver.
				This user value is sent once per login attempt and passed to the accounts server.
\item[$K_s$]	The site key belonging to $U_h$, sent by the accounts server.
				Eavesdropping on this traffic will give the hacker a set of combinations of values.
				Having $K_s$ for each user is of no value, since the hacker does not have the means
				(array $S$ in the HSM of the login server)
				to turning this into $K_u$ which is needed to login.
\item[$A_u$]	A random number XOR-ed with the user key $K_u$ is sent to the webserver.
				The random number is different for each login attempt.
				This random number is most likely generated by a suboptimal pseudo-random generator,
				namely the generator of a PC, tablet, or smart phone.
				Even so, you cannot easily determine $K_u$ from this value,
				since this value is sent once per login attempt.
				Harvesting large quantities is practially infeasible,
				so statistical analysis will fail.
\item[$B_s$]	The login server tries to decrypt the random number $R_u$ from the user by regenerating the user key $K_u$.
				It then returns the least significant 128 bits of the \SHA\ hash of the found random value to the webserver,
				which passes it to the user.
				This value is sent repeatedly until the right user key has been found.
				Since different user keys will be tried, the hash value will differ each time.
				None of the hashes returned this way give any hint to $R_u$ nor $K_u$.
\item[$P_s$]	The webserver also receives a random number XOR-ed with the regenerated user key $K_u$ from the login server.
				If the login server chooses to change keys,
				the random number contained in $P_s$ will be the new user key $K_u$
				but further undistinghuishable from any other random value.
				Since $P_s$ depends on $R_s$
				(which is a good quality pseudo-random number from an HSM and different for each $P_s$)
				$K_u$ cannot be calculated from a single or a series of $P_s$ values.
\item[$Q_s$]	The response of the user to the $P_s$ challenge sent by the login server.
				Used for comparison with $Q_u$ sent by the user.
\item[$Q_u$]	The user returns the the least significant 128 bits of the \SHA\ of the random number from the webserver.
				The lower half of the \SHA\ value of $R_s$ can never be used to calculate $R_s$,
				so therefore $K_u$ can never be calculated from a single or a series of $Q_u$ values.
\end{description}
The only practical data present at the webserver would be the set of all $U_h$ values,
since these values are a direct link to an account for the website.
Logging in will not be possible;
the only harm that can come from this is a denial-of-service attack,
by trying to login with bogus keys,
so that accounts are locked out for some time.
%^^^^^^^^
\paragraph{Values passing the login server}
\begin{description}
\item[$A_u$]	The webserver sends this value to the login server:
	a random encrypted with the user key.
	The value $B_s$ will be calculated in response to this.
\item[$K_s$]	The site key belonging to the user.
	The login server will temporarily regenerate the user key $K_u$ from this within the HSM.
\item[$i$]	The index to use when selecting Secret keys.
	Increments with each attempt.
\item[$B_s$]	The response to challenge $A_u$.
	This value is returned to the webserver.
\item[$P_s$]	The challenge the webserver will send the user.
\item[$Q_s$]	The answer to this challenge.
\end{description}
The values exchanged here
(except $i$)
are random values or hashes thereof.
The random value $R_s$ in the HSM used to create $P_s$ and $Q_s$ cannot be guessed from these two values,
since only half the value of the \SHA\ hash is returned with $Q_s$.
Therefore, the user key $K_u$ is also secured.
Since the Secret keys are kept in an HSM,
$K_u$ cannot be derived from $K_s$.
The $K_s$ value cannot be related to any account from the webserver,
as only the webserver knows to which login attempt these values belong
and cannot be derived from any value exchanged here.


\subsection{Manipulating values}
\label{sec:manipulating_values}
The hacker has control over values $U_h$, $A_u$, and $Q_u$, which he or she can change to any bit pattern.
Values $U_h$ and $A_u$ are sent once during a login.
\par
Userid harvesting malware must replace the system function of generating random numbers
and be able to intercept network packets before they are encrypted by the SSL/TLS software.
That would mean replacing a function of the SSL library as well.
Only then can they calculate the user key $K_u$,
using the known random values,
and filter out the userid hash $U_h$.
\par
Sending a random value for $U_h$ always gives you a response.
In most cases a zero value for $B_s$ and $P_s$ are returned,
indicating that no record exists belonging to $U_h$.
Given the fact that $U_k$ depends on $Z[0]$ and a userid,
finding a valid $U_h$ will only be possible when the keyring
has been successfully decrypted.
Generating specific values for $U_h$ by guessing userid's and sending those to a webserver
(along with a random value for $A_u$)
might give rise to non-zero
(but bogus)
values for $B_s$ and $P_s$.
In that case a userid has been harvested.
From that moment on each key in the keyring can be tried to see if it fits.
\par
Suppose a valid $U_h$ has been found.
All the webserver will do with any value of $A_u$ is decrypt it with a key dependent on $U_h$,
and return the least significant 128 bits of the \SHA\ hash of this.
Should \SHA\ somehow be totally reversible,
having only half the value leaves $2^{128}$ possible values for the random value,
so no user key or site key can be obtained this way.
