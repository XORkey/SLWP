\subsection{On randomness}
The \TIMO\ protocol relies heavily on random numbers.
If they were not random, the protocol is rendered useless, to a degree proportional to the non-randomness.
\subsubsection{Generating random numbers}
True random numbers are generated bit by bit
(e.g. sampling white noise);
the pseudo-random numbers used here are typically generated by several bytes simultaneously,
by a deterministic algorithm.
Ideally,
the generated stream of bits are random to a
(very)
high degree.
Randomness comes in several ways.
There should be no predictive value in the bits that are already generated,
so future bits cannot be determined by past bits,
nor past bits by future bits.
\par
This should be the case for any bit in the smallest generated quantity of simultaneously computed random bits.
Either when scanning from left to right or vice versa, or any other sequence for that matter.
No bits should be predictable from any and all other bits in the sequence.
\par
This trait should also exist between any number of previously generated
(groups of)
bits and future
(groups of)
bits,
in any sequence.
We know that,
since we generating pseudo-random numbers,
this assertion will not hold on one point,
as the entire sequence repeats itself after a
(very,
sometimes extremely)
large number of bits.
\subsubsection{Randomness of keys}
The secret keys that are used by the login server to encrypt site keys are generated by the HSM,
which means they can be considered highly random.
Site keys are also generated by the HSM,
therefore having the same quality.
User keys are the \AES\ encryption of site keys;
if anything,
this process does not reduce entropy,
so user keys are also highly random.
\par
Although keys are replaced every now an then,
they can be considered static in this context.
\subsubsection{Randomness of $R_s$ and $R_u$}
Site Random numbers
($R_s$)
are generated by the HSM of the login server and have a high randomness.
The User Random numbers
($R_u$)
are ultimately generated by the operating system of the system running the client part of the protocol.
In the login server we have the benefit of having an HSM,
but when the protocol is implemented on a tiny device in a SCADA environment for instance,
we cannot assume that high quality random numbers will always be generated.
\subsubsection{The use of random numbers in \TIMO}
The core principle of the \TIMO\ protocol is mutually being able to prove the posession of a key.
The user proves this by decrypting
(the highly random)
$R_s$,
and replying with the \XOR\ of the aquired random and its own random.
The web server proves this by decrypting
(the potentially not so random)
$R_u$,
and providing the user with a partial \SHA\ hash of that.
\par
The user random $R_u$ is generated once per login sequence
(which may require more than one attempt).
The site random $R_s$ is generated on the first attempt in the sequence
and is only used in that attempt.
Subsequent attempts use a new user key $K_u$ instead,
which is repeated from that attempt onwards.
\par
If $R_u$ values are of guaranteed high quality,
we can sufficiently hide the user key $K_u$ by simply computing $A_u$ as
\[A_u=\xor{R_u}{K_u}\]
However,
we have no guarantees about the random numbers generated by the user,
so using \XOR\ with would potentially expose user key $K_u$ if the random number generator were to be manipulated.
Instead we use 
\[A_u=\EAES{R_u}{K_u}\]
to protect $K_u$ better.
However, the calculation of $A_u$ is done in the browser,
possibly with JavaScript,
which may be otherwise broken and may expose $K_u$ directly or by other means.
